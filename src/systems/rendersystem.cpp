#include "rendersystem.h"
/**
* @brief Constructor for RenderSystem objects to set needed references.
* @param spriteManager - Reference to the sprite manager for sprite objects.
* @param positionManager  - Reference to the position manager for position objects.
* @param renderer - Reference to the SDL_Renderer for the actual rendering of the sprites in the gameworld.
*/
RenderSystem::RenderSystem(ComponentManager<Sprite>* spriteManager, ComponentManager<Position>* positionManager, SDL_Renderer* renderer, ComponentManager<CameraFollow>* cameraFollowManager) {
	this->positionManager = positionManager;
	this->spriteManager = spriteManager;
	this->renderer = renderer;
	this->cameraFollowManager = cameraFollowManager;

	// TODO: outsource camera initialization
	camera = {0, 0, 800, 640};
}

/**
* @brief Render system update loop. Iterates over every sprite object and renders the texture to the position of the entity holding the sprite.	
*/
void RenderSystem::update() {
	// clear renderer
	SDL_RenderClear(renderer);

	moveCamera();

	renderTilemap();

	renderSprites();

	render();
}

/**
* @brief Renders all current sprites in the window.
*/
void RenderSystem::renderSprites() {
	unsigned int index = spriteManager->getComponentCount();
	for (size_t i = 0; i < index; i++)
	{
		Sprite* sprite = spriteManager->getComponentWithIndex(i);
		Entity spriteEntity = sprite->getEntity();
		Position* spritePosition = positionManager->getComponent(spriteEntity);
		sprite->setDestinationRectPosition((spritePosition->x - (sprite->getDestinationWidth() / 2))-camera.x, (spritePosition->y - (sprite->getDestinationHeight() / 2))-camera.y);
		draw(sprite);
	}
}


/**
 * @brief Checks if the sprite has a texture and creates a texture if it has not. Afterwards adds the sprite to the renderer to render.
 * @param sprite 
*/
void RenderSystem::draw(Sprite* sprite) {
	// if sprite has no texture
	if (!sprite->hasTexture()) {
		// create texture
		SDL_Surface* tempSurface = IMG_Load(sprite->texturePath);
		SDL_Texture* spriteTexture = SDL_CreateTextureFromSurface(renderer, tempSurface);

		// cleanup surface
		SDL_FreeSurface(tempSurface);

		// set texture of sprite
		sprite->setTexture(spriteTexture);
	}
	SDL_RenderCopy(renderer, sprite->getTexture(), NULL, sprite->getDestinationRect());
}

/**
 * @brief Render the current textures of the renderer.
*/
void RenderSystem::render() {
	SDL_RenderPresent(renderer);
}

/**
* @brief Sets the current tilemap to display.
* @param tilesetPath - Path to tileset image used by tilemap.
* @param tilemapPath - Path to tilemap json file generated by tiled.
* @param layerCount - Count of layers in tilemap.
*/
void RenderSystem::setMap(const char* tilesetPath, const char* tilemapPath, size_t layerCount) {
	SDL_Point size;
	tilemap = FileLoader::loadTilemap(tilemapPath, layerCount);

	// create texture
	SDL_Surface* tempSurface = IMG_Load(tilesetPath);
	SDL_Texture* tempTexture = SDL_CreateTextureFromSurface(renderer, tempSurface);

	// get tileset width/height
	SDL_QueryTexture(tempTexture, NULL, NULL, &size.x, &size.y);

	tileset = new Tileset(tempTexture, size.x, size.y);

	// set srcRect
	tileset->initSourceRect(tilemap->getTileWidth(), tilemap->getTileHeight());

	// set destRect
	tileset->initDestinationRect(tilemap->getTileWidth(), tilemap->getTileHeight());

	// cleanup surface
	SDL_FreeSurface(tempSurface);
}

/**
* @brief Renders the tilemap.
*/
void RenderSystem::renderTilemap() {
	unsigned int tileWidth, tileHeight, currentDestX, currentDestY, maxTilesPerRow;
	currentDestX = 0;
	currentDestY = 0;
	maxTilesPerRow = tilemap->getMapWidth();
	tileWidth = tilemap->getTileWidth();
	tileHeight = tilemap->getTileHeight();
	size_t layers = tilemap->getLayerCount();

	for (size_t i = 0; i < layers; i++)
	{
		std::vector<unsigned int> layer = tilemap->getLayer(i);
		for (size_t i = 0; i < layer.size(); i++)
		{
			// checks if current x-position is greater or equals to max tilecount in row
			if (currentDestX >= maxTilesPerRow) {
				currentDestX = 0;
				currentDestY = currentDestY + 1;
			}
			// check if spot is empty
			if (layer[i] != 0) {
				// calculate part to render
				setTilesetSrcRectPosition(layer[i], tileWidth, tileHeight);

				// calculate part to render at ingame
				setTilesetDestRectPosition(currentDestX, currentDestY, maxTilesPerRow, tileWidth, tileHeight);

				SDL_RenderCopy(renderer, tileset->getTexture(), tileset->getSourceRect(), tileset->getDestinationRect());
			}
			currentDestX = currentDestX + 1;
		}
		currentDestX = 0;
		currentDestY = 0;
	}
}

/**
* @brief Sets the source rectangle of the tileset to display the right part of the tileset.
* @param tilemapData - What tile to display based on the tilemap.
* @param tileWidth - Width of the tiles.
* @param tileHeight - Height of the tiles.
*/
void RenderSystem::setTilesetSrcRectPosition(unsigned int tilemapData, unsigned int tileWidth, unsigned int tileHeight) {
	unsigned int tilesetWidth = tileset->getTilesetWidth();

	int newX;
	int newY;
	// check if first row tileWidth * maxWidth
	if ((tilemapData * tileWidth) <= (tilesetWidth)) {
		newX = (tilemapData == 0) ? tilemapData * tileWidth : (tilemapData - 1) * tileWidth;
		newY = 0;
	}
	else {
		// calculate row
		unsigned int yoffset = (tilemapData * tileWidth) / (tilesetWidth);
		unsigned int xoffset = ((tilemapData * tileWidth) % (tilesetWidth)) / tileWidth;

		newX = (xoffset == 0) ? xoffset * tileWidth : (xoffset - 1) * tileWidth;
		newY = yoffset * tileHeight;
	}
	// set source rect position
	tileset->setSourceRect(newX, newY);
}

/**
* @brief Sets the destination rectangle of the tileset to display the tiles in the right area.
* @param currentX - Current X position on the tilemap.
* @param currentY - Current Y position on the tilemap.
* @param maxTilesPerRow - Maxixum tiles per row on the tilemap.
* @param tileWidth - Width of the tiles.
* @param tileHeight - Height of the tiles.
*/
void RenderSystem::setTilesetDestRectPosition(unsigned int currentX, unsigned int currentY, unsigned int maxTilesPerRow, unsigned int tileWidth, unsigned int tileHeight) {
	int newX;
	int newY;

	if (currentX < maxTilesPerRow) {
		newX = (currentX == 0) ? currentX * tileWidth : (currentX - 1) * tileWidth;
		newY = (currentY == 0) ? currentY * tileHeight : (currentY - 1) * tileHeight;
	}
	else {
		// set new position
		newX = (currentX == 0) ? currentX * tileWidth : (currentX - 1) * tileWidth;
		newY = (currentY == 0) ? currentY * tileHeight : (currentY - 1) * tileHeight;
	}
	// substracts the calculated tile position based on tilewidth & the position on the tilemap from the camera origin position (top-left).
	// if the result is positiv, render the tile on the substracted position (relative to the camera origin).
	// if the result is negativ, don't render the tile.
	newX = newX - camera.x;
	newY = newY - camera.y;

	//std::cout << "Tile dest pos: (" << newX << ", " << newY << ");" << std::endl;
	tileset->setDestinationRect(newX, newY);
}

/**
 * @brief Moves the camera to the entity with the follow camera component.
*/
void RenderSystem::moveCamera() { 
	if (cameraFollowManager->getComponentCount() == 1) {
		Entity followTarget = cameraFollowManager->getComponentWithIndex(0)->getEntity();
		Position* followPosition = positionManager->getComponent(followTarget);

		camera.x = followPosition->x - (camera.w / 2);
		camera.y = followPosition->y - (camera.h / 2);

		// check the camera bounds
		// top-left
		if (camera.x < 0) {
			camera.x = 0;
		}
		if (camera.y < 0) {
			camera.y = 0;
		}

		//bottom-right
		if (camera.x > camera.w) {
			camera.x = camera.w;
		}

		if (camera.y > camera.h) {
			camera.y = camera.h;
		}
	}
}